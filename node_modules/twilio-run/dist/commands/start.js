"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.builder = exports.describe = exports.command = exports.cliInfo = exports.handler = void 0;
const inquirer_1 = __importDefault(require("inquirer"));
const nodejs_version_1 = __importDefault(require("../checks/nodejs-version"));
const project_structure_1 = __importDefault(require("../checks/project-structure"));
const start_1 = require("../config/start");
const start_2 = require("../printers/start");
const server_1 = require("../runtime/server");
const inspector_1 = require("../runtime/utils/inspector");
const logger_1 = require("../utils/logger");
const shared_1 = require("./shared");
const utils_1 = require("./utils");
const debug = logger_1.getDebugFunction('twilio-run:start');
function randomPort() {
    // Returns a random port number higher than 1024 and lower than 65536.
    return Math.floor(Math.random() * (65535 - 1025) + 1025);
}
function validatePortNumber(input) {
    const newPortNumber = parseInt(input, 10);
    if (!Number.isNaN(newPortNumber) &&
        newPortNumber <= 65535 &&
        newPortNumber > 1024) {
        return true;
    }
    return 'Please enter a port number between 1025 and 65535.';
}
function handler(argv, externalCliOptions) {
    return __awaiter(this, void 0, void 0, function* () {
        logger_1.setLogLevelByName(argv.logLevel);
        nodejs_version_1.default();
        const config = yield start_1.getConfigFromCli(argv, exports.cliInfo, externalCliOptions);
        const command = utils_1.getFullCommand(argv);
        const directories = {
            assetsDirectories: config.assetsFolderName
                ? [config.assetsFolderName]
                : undefined,
            functionsDirectories: config.functionsFolderName
                ? [config.functionsFolderName]
                : undefined,
        };
        yield project_structure_1.default(config.baseDir, command, false, directories);
        debug('Determined configuration: %p', config);
        process.title = config.appName;
        debug('Set environment variables as: %r', config.env);
        process.env = config.env;
        if (config.inspect) {
            debug('Starting inspector mode with following configuration: %p', config.inspect);
            inspector_1.startInspector(config.inspect.hostPort, config.inspect.break);
        }
        const app = yield server_1.createServer(config.port, config);
        debug('Start server on port %d', config.port);
        return new Promise((resolve, reject) => {
            let attempts = 1;
            const MAX_ATTEMPTS = 3;
            const serverStartedSuccessfully = () => __awaiter(this, void 0, void 0, function* () {
                start_2.printRouteInfo(config);
                resolve();
            });
            const handleServerError = (error) => __awaiter(this, void 0, void 0, function* () {
                if (error.code === 'EADDRINUSE') {
                    if (attempts > MAX_ATTEMPTS) {
                        logger_1.logger.info('Too many retries. Please check your available ports.');
                        process.exit(1);
                    }
                    else {
                        const answers = yield inquirer_1.default.prompt([
                            {
                                type: 'input',
                                default: randomPort(),
                                name: 'newPortNumber',
                                message: `Port ${config.port} is already in use. Choose a new port number:`,
                                validate: validatePortNumber,
                            },
                        ]);
                        attempts += 1;
                        const server = app.listen(answers.newPortNumber, serverStartedSuccessfully);
                        server.on('error', handleServerError);
                    }
                }
                else {
                    reject(error);
                }
            });
            const server = app.listen(config.port, serverStartedSuccessfully);
            server.on('error', handleServerError);
        });
    });
}
exports.handler = handler;
exports.cliInfo = {
    options: Object.assign(Object.assign({}, shared_1.sharedCliOptions), { 'load-local-env': {
            alias: 'f',
            default: false,
            type: 'boolean',
            describe: 'Includes the local environment variables',
        }, cwd: {
            type: 'string',
            describe: 'Alternative way to define the directory to start the server in. Overrides the [dir] argument passed.',
        }, env: {
            alias: 'e',
            type: 'string',
            describe: 'Loads .env file, overrides local env variables',
        }, port: {
            alias: 'p',
            type: 'string',
            describe: 'Override default port of 3000',
            default: '3000',
            requiresArg: true,
        }, ngrok: {
            type: 'string',
            describe: 'Uses ngrok to create and outfacing url',
        }, logs: {
            type: 'boolean',
            default: true,
            describe: 'Toggles request logging',
        }, 'detailed-logs': {
            type: 'boolean',
            default: false,
            describe: 'Toggles detailed request logging by showing request body and query params',
        }, live: {
            type: 'boolean',
            default: true,
            describe: 'Always serve from the current functions (no caching)',
        }, inspect: {
            type: 'string',
            describe: 'Enables Node.js debugging protocol',
        }, 'inspect-brk': {
            type: 'string',
            describe: 'Enables Node.js debugging protocol, stops executioin until debugger is attached',
        }, 'legacy-mode': {
            type: 'boolean',
            describe: 'Enables legacy mode, it will prefix your asset paths with /assets',
        }, 'assets-folder': {
            type: 'string',
            describe: 'Specific folder name to be used for static assets',
        }, 'functions-folder': {
            type: 'string',
            describe: 'Specific folder name to be used for static functions',
        } }),
};
function optionBuilder(yargs) {
    yargs = yargs
        .example('$0', 'Serves all functions in current functions subdirectory')
        .example('$0 start demo', 'Serves all functions in demo/functions')
        .example('PORT=9000 $0', 'Serves functions on port 9000')
        .example('$0 start --port=4200', 'Serves functions on port 4200')
        .example('$0 start --env', 'Loads environment variables from .env file')
        .example('$0 start --ngrok', 'Exposes the Twilio functions via ngrok to share them')
        .epilog('for more information, check out https://twil.io/local-functions');
    yargs = Object.keys(exports.cliInfo.options).reduce((yargs, name) => {
        return yargs.option(name, exports.cliInfo.options[name]);
    }, yargs);
    return yargs;
}
exports.command = ['start [dir]', '$0 [dir]'];
exports.describe = 'Starts local Twilio Functions development server';
exports.builder = optionBuilder;
